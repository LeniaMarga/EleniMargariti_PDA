'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Queue = exports.wait = undefined;

var _createClass = function () { var defineProperties = function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }; return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Very thin implementation. Streamline.js does all the work.


exports.run = run;
exports.map = map;
exports.funnel = funnel;
exports.handshake = handshake;
exports.withContext = withContext;
exports.context = context;
exports.wait_ = wait_;
exports.canWait = canWait;
exports.eventHandler = eventHandler;

var _streamlineRuntime = require('streamline-runtime');

var _streamline = typeof require === 'function' ? require('streamline-runtime/lib/fibers/runtime') : Streamline.require('streamline-runtime/lib/fibers/runtime');

var _filename = '/Users/bruno/dev/f-promise/src/index.ts';

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
}

var fibers = require('fibers');
function _wait(arg) {
    if (typeof arg === 'function') {
            // fiberized test optimizes calls to streamlined thunks: (_: _) => T 
            var fiberized = arg['fiberized-0'];
            if (fiberized) return fiberized(true);else return _wait(_streamlineRuntime._.promise(_streamline.async(function _$$$$(_2) {
                return _streamline.await(_filename, 11, null, _streamlineRuntime._.cast(arg), 0, null, false, [true]);
            }, 0, 1)));
        } else {
            var streamlined = _streamline.async(function _$$$$2(_3) {
                return _streamline.await(_filename, 14, arg, 'then', 0, 1, false, [true, true]);
            }, 0, 1);
            return streamlined['fiberized-0'].call(null, true);
        }
}
exports.wait = _wait;
function run(fn) {
    return _streamlineRuntime._.promise(_streamline.async(function _$$$$3(_4) {
        return fn();
    }, 0, 1));
}
function map(collection, fn) {
    return collection.map(function (item) {
        return run(function () {
            return fn(item);
        });
    }).map(_wait);
}
function funnel(n) {
    var fun = _streamlineRuntime._.funnel(n);
    return function (fn) {
        return _wait(_streamline.async(function _$$$$4(_5) {
            return _streamline.await(_filename, 28, null, fun, 0, null, false, [true, _streamline.async(function _$$$$5(_6) {
                return fn();
            }, 0, 1)]);
        }, 0, 1));
    };
}
/// 
/// ## handshake and queue
/// * `hs = handshake()`  
///   allocates a simple semaphore that can be used to do simple handshakes between two tasks.  
///   The returned handshake object has two methods:  
///   `hs.wait()`: waits until `hs` is notified.  
///   `hs.notify()`: notifies `hs`.  
///   Note: `wait` calls are not queued. An exception is thrown if wait is called while another `wait` is pending.
function handshake() {
    var callback = undefined,
        notified = false;
    return {
        wait: function wait() {
            return _wait(function (cb) {
                if (callback) throw new Error('already waiting');
                if (notified) setImmediate(cb);else callback = cb;
                notified = false;
            });
        },
        notify: function notify() {
            if (!callback) notified = true;else setImmediate(callback);
            callback = undefined;
        }
    };
}

var Queue = exports.Queue = function () {
    var Queue = function Queue(options) {
        _classCallCheck(this, Queue);

        this._q = [];
        this._pendingWrites = [];
        if (typeof options === 'number') {
                options = {
                    max: options
                };
            }
        options = options || {};
        this._max = options.max != null ? options.max : -1;
    };

    _createClass(Queue, [{
        key: 'read',
        value: function read() {
            var _this = this;

            return _wait(function (cb) {
                if (_this._callback) throw new Error('already getting');
                if (_this._q.length > 0) {
                        var item = _this._q.shift();
                        // recycle queue when empty to avoid maintaining arrays that have grown large and shrunk
                        if (_this._q.length === 0) _this._q = [];
                        setImmediate(function () {
                            cb(_this._err, item);
                        });
                        if (_this._pendingWrites.length > 0) {
                                var wr = _this._pendingWrites.shift();
                                setImmediate(function () {
                                    wr && wr[0](_this._err, wr[1]);
                                });
                            }
                    } else {
                        _this._callback = cb;
                    }
            });
        }
        ///   `q.write(data)`:  queues an item. Waits if the queue is full.  

    }, {
        key: 'write',
        value: function write(item) {
            var _this2 = this;

            return _wait(function (cb) {
                if (_this2.put(item)) {
                        setImmediate(function () {
                            cb(_this2._err);
                        });
                    } else {
                        _this2._pendingWrites.push([cb, item]);
                    }
            });
        }
        ///   `ok = q.put(data)`: queues an item synchronously. Returns true if the queue accepted it, false otherwise. 

    }, {
        key: 'put',
        value: function put(item, force) {
            var _this3 = this;

            if (!this._callback) {
                    if (this._max >= 0 && this._q.length >= this._max && !force) return false;
                    this._q.push(item);
                } else {
                    var cb = this._callback;
                    this._callback = undefined;
                    setImmediate(function () {
                        cb(_this3._err, item);
                    });
                }
            return true;
        }
        ///   `q.end()`: ends the queue. This is the synchronous equivalent of `q.write(_, undefined)`  

    }, {
        key: 'end',
        value: function end() {
            this.put(undefined, true);
        }
        ///   `data = q.peek()`: returns the first item, without dequeuing it. Returns `undefined` if the queue is empty.  

    }, {
        key: 'peek',
        value: function peek() {
            return this._q[0];
        }
        ///   `array = q.contents()`: returns a copy of the queue's contents.  

    }, {
        key: 'contents',
        value: function contents() {
            return this._q.slice(0);
        }
        ///   `q.adjust(fn[, thisObj])`: adjusts the contents of the queue by calling `newContents = fn(oldContents)`.  

    }, {
        key: 'adjust',
        value: function adjust(fn) {
            var nq = fn.call(null, this._q);
            if (!Array.isArray(nq)) throw new Error('adjust function does not return array');
            this._q = nq;
        }
    }, {
        key: 'length',
        get: function get() {
            return this._q.length;
        }
    }]);

    return Queue;
}();
/// 
/// ## Continuation local storage (CLS)
/// 
/// * `result = withContext(fn, cx)`  
///   wraps a function so that it executes with context `cx` (or a wrapper around current context if `cx` is falsy).
///   The previous context will be restored when the function returns (or throws).  
///   returns the wrapped function.


function withContext(fn, cx) {
    if (!fibers.current) throw new Error('withContext(fn) not allowed outside run()');
    return _streamlineRuntime._.withContext(fn, cx)();
}
function context() {
    return _streamlineRuntime._.context;
}
// wait variant for streamline.js
// Callback parameter is typed as any so that f-promise does not re-export streamline-runtime's _ definition.
function wait_(arg) {
    var fiberized = arg['fiberized-0'];
    return fiberized(true);
}
/// 
/// ## Miscellaneous
/// 
/// * `ok = canWait()`  
///   returns whether `wait` calls are allowed (whether we are called from a `run`).
function canWait() {
    return !!fibers.current;
}
/// 
/// * `wrapped = eventHandler(handler)`  
///   wraps `handler` so that it can call `wait`.  
///   the wrapped handler will excute on the current fiber if canWait() is true.
///   otherwise it will be `run` on a new fiber (without waiting for its completion)  
function eventHandler(handler) {
    var wrapped = function wrapped() {
        var _this4 = this;

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        if (canWait()) handler.apply(this, args);else run(function () {
            return withContext(function () {
                return handler.apply(_this4, args);
            }, {});
        }).catch(function (err) {
            throw err;
        });
    };
    // preserve arity
    Object.defineProperty(wrapped, 'length', { value: handler.length });
    return wrapped;
}
//# sourceMappingURL=index.js.map